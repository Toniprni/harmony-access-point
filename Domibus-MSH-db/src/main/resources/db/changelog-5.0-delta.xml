<?xml version="1.0" encoding="UTF-8"?>

<databaseChangeLog
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.4.xsd">

    <!-- properties - to be used in column definitions -->
    <include file="common/changelog-properties-v2.xml" relativeToChangelogFile="true"/>

    <!-- sequences -->
    <changeSet dbms="oracle" author="idragusa" id="EDELIVERY-7836">
        <comment>create DOMIBUS_SCALABLE_SEQUENCE</comment>
        <sqlFile path="src/main/resources/db/common/oracle-sequence-create.sql"/>
        <sqlFile path="src/main/resources/db/common/oracle-sequence-functions.sql" endDelimiter="\n/"/>
    </changeSet>

    <changeSet dbms="mysql,h2" author="gautifr" id="EDELIVERY-7836">
        <comment>create DOMIBUS_SCALABLE_SEQUENCE</comment>
        <createTable tableName="DOMIBUS_SCALABLE_SEQUENCE">
            <column name="sequence_name" type="VARCHAR(255)">
                <constraints primaryKey="true" primaryKeyName="PK_DOMIBUS_SCALABLE_SEQUENCE"/>
            </column>
            <column name="next_val" type="bigint"/>
        </createTable>
    </changeSet>

    <changeSet author="Francois Gautier" id="EDELIVERY-2427">
        <comment>WS Plugin specific tables for backend dispatch</comment>
        <createTable tableName="WS_PLUGIN_TB_BACKEND_MSG_LOG">
            <column name="ID_PK" type="BIGINT" autoIncrement="true" remarks="Primary key identifying the record of the table">
                <constraints primaryKey="true" primaryKeyName="PK_WS_PLUGIN_BACKEND_MSG_LOG"/>
            </column>

            <column defaultValueComputed="${now}" name="CREATION_TIME" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${current_db_user}" name="CREATED_BY" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="MODIFICATION_TIME" type="TIMESTAMP"/>
            <column name="MODIFIED_BY" type="VARCHAR(255)"/>

            <column name="MESSAGE_ID" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="FINAL_RECIPIENT" type="VARCHAR(255)"/>
            <column name="ORIGINAL_SENDER" type="VARCHAR(255)"/>

            <column name="BACKEND_MESSAGE_STATUS" type="VARCHAR(255)"/>
            <column name="MESSAGE_STATUS" type="VARCHAR(255)"/>
            <column name="BACKEND_MESSAGE_TYPE" type="VARCHAR(255)"/>

            <column name="RULE_NAME" type="VARCHAR(255)" remarks="Name of the rule used for dispatching"/>
            <column name="SENT" type="DATETIME" remarks="DateTime when the message had been dispatched">
                <constraints nullable="false"/>
            </column>
            <column name="FAILED" type="DATETIME" remarks="DateTime when the message had failed"/>

            <column name="SEND_ATTEMPTS" type="INT" remarks="Number of attempts sent"/>
            <column name="SEND_ATTEMPTS_MAX" type="INT" remarks="Number of attempts maximal"/>
            <column name="NEXT_ATTEMPT" type="DATETIME" remarks="DateTime for the next attempt"/>

            <column name="SCHEDULED" type="BOOLEAN" remarks="true if the backend message is already scheduled to be sent"/>
        </createTable>
    </changeSet>

    <changeSet id="EDELIVERY-4808" author="Catalin Enache">
        <addColumn tableName="WS_PLUGIN_TB_MESSAGE_LOG">
            <column name="CONVERSATION_ID" type="VARCHAR(255)"/>
            <column name="REF_TO_MESSAGE_ID" type="VARCHAR(255)"/>
            <column name="FROM_PARTY_ID" type="VARCHAR(255)"/>
            <column name="ORIGINAL_SENDER" type="VARCHAR(255)"/>
        </addColumn>
    </changeSet>

    <changeSet author="Ion Perpegel" id="EDELIVERY-7472">
        <comment>split plugin user unique constraints in 2</comment>
        <dropUniqueConstraint uniqueColumns="USERNAME,CERTIFICATE_ID" constraintName="UQ_PLUGIN_USER"
                             tableName="TB_AUTHENTICATION_ENTRY"/>
        <addUniqueConstraint columnNames="USERNAME" constraintName="UK_PLUGIN_USER_NAME"
                             tableName="TB_AUTHENTICATION_ENTRY"/>
        <addUniqueConstraint columnNames="CERTIFICATE_ID" constraintName="UK_PLUGIN_USER_CERT"
                             tableName="TB_AUTHENTICATION_ENTRY"/>

    </changeSet>

    <!-- Start UI Replication Tables -->
    <changeSet author="Sebastian-Ion TINCU" id="EDELIVERY-8384-temporary-drop-ui-replication-table">
        <dropTable tableName="TB_MESSAGE_UI" cascadeConstraints="true" />
    </changeSet>

    <!--<changeSet author="Ion Perpegel" id="EDELIVERY-7677">
        <comment>adding columns for action and service</comment>
        <addColumn tableName="TB_MESSAGE_UI">
            <column name="ACTION" type="VARCHAR(255)" remarks="The action of the collaboration of the message"/>
            <column name="SERVICE_TYPE" type="VARCHAR(255)" remarks="The service type of the collaboration of the message"/>
            <column name="SERVICE_VALUE" type="VARCHAR(255)" remarks="The service value of the collaboration of the message"/>
        </addColumn>

        <createIndex indexName="IDX_MSG_UI_ACTION" tableName="TB_MESSAGE_UI">
            <column name="ACTION"/>
        </createIndex>

        <createIndex indexName="IDX_MSG_UI_SRV_TYPE" tableName="TB_MESSAGE_UI">
            <column name="SERVICE_TYPE"/>
        </createIndex>

        <createIndex indexName="IDX_MSG_UI_SRV_VAL" tableName="TB_MESSAGE_UI">
            <column name="SERVICE_VALUE"/>
        </createIndex>
    </changeSet>

    <changeSet id="EDELIVERY-7677-1" author="Ion Perpegel" dbms="oracle">
        <comment>re-create UI Replication view cause of the added columns: action,service</comment>
        <createView
                replaceIfExists="true"
                viewName="V_MESSAGE_UI_DIFF">
            SELECT
            message_id,
            message_status,
            notification_status,
            msh_role,
            message_type,
            deleted,
            received,
            send_attempts,
            send_attempts_max,
            next_attempt,
            fk_timezone_offset,
            conversation_id,
            from_id,
            to_id,
            from_scheme,
            to_scheme,
            ref_to_message_id,
            failed,
            restored,
            message_subtype,
            action,
            service_type,
            service_value
            FROM
            (
            SELECT
            message_log.message_id,
            message_log.message_status,
            message_log.notification_status,
            message_log.msh_role,
            message_log.message_type,
            message_log.deleted,
            message_log.received,
            message_log.send_attempts,
            message_log.send_attempts_max,
            message_log.next_attempt,
            message_log.fk_timezone_offset,
            user_message.coll_info_convers_id AS conversation_id,
            partyid5_.value AS from_id,
            partyid6_.value AS to_id,
            property.value AS from_scheme,
            property2.value AS to_scheme,
            message_info.ref_to_message_id,
            message_log.failed,
            message_log.restored,
            message_log.message_subtype,
            user_message.collaboration_info_action AS action,
            user_message.service_type,
            user_message.service_value
            FROM
            tb_message_log message_log
            LEFT OUTER JOIN tb_message_info message_info ON message_log.message_id =
            message_info.message_id,tb_user_message user_message
            LEFT OUTER JOIN tb_property property ON user_message.id_pk = property.messageproperties_id
            LEFT OUTER JOIN tb_property property2 ON user_message.id_pk = property2.messageproperties_id
            LEFT OUTER JOIN tb_party_id partyid5_ ON user_message.id_pk = partyid5_.from_id
            LEFT OUTER JOIN tb_party_id partyid6_ ON user_message.id_pk = partyid6_.to_id
            WHERE
            user_message.messageinfo_id_pk = message_info.id_pk
            AND property.name = 'originalSender'
            AND property2.name = 'finalRecipient'
            UNION
            SELECT
            message_log.message_id,
            message_log.message_status,
            message_log.notification_status,
            message_log.msh_role,
            message_log.message_type,
            message_log.deleted,
            message_log.received,
            message_log.send_attempts,
            message_log.send_attempts_max,
            message_log.next_attempt,
            message_log.fk_timezone_offset,
            '' AS conversation_id,
            partyid7_.value AS from_id,
            partyid8_.value AS to_id,
            property.value AS from_scheme,
            property2.value AS to_scheme,
            message_info.ref_to_message_id,
            message_log.failed,
            message_log.restored,
            message_log.message_subtype,
            null as action,
            null as service_type,
            null as service_value
            FROM
            tb_message_log message_log
            CROSS JOIN tb_messaging messaging
            INNER JOIN tb_signal_message signalmess2_ ON messaging.signal_message_id = signalmess2_.id_pk
            LEFT OUTER JOIN tb_message_info message_info ON signalmess2_.messageinfo_id_pk = message_info.id_pk
            INNER JOIN tb_user_message user_message ON messaging.user_message_id = user_message.id_pk
            LEFT OUTER JOIN tb_property property ON user_message.id_pk = property.messageproperties_id
            LEFT OUTER JOIN tb_property property2 ON user_message.id_pk = property2.messageproperties_id
            LEFT OUTER JOIN tb_party_id partyid7_ ON user_message.id_pk = partyid7_.from_id
            LEFT OUTER JOIN tb_party_id partyid8_ ON user_message.id_pk = partyid8_.to_id
            CROSS JOIN tb_message_info message_info2
            WHERE
            user_message.messageinfo_id_pk = message_info2.id_pk
            AND message_info.message_id = message_log.message_id
            AND message_info.ref_to_message_id = message_info2.message_id
            AND property.name = 'originalSender'
            AND property2.name = 'finalRecipient'
            ) result WHERE result.received BETWEEN systimestamp - INTERVAL '48' HOUR AND systimestamp + INTERVAL '1'
            HOUR
            MINUS
            SELECT
            message_id,
            message_status,
            notification_status,
            msh_role,
            message_type,
            deleted,
            received,
            send_attempts,
            send_attempts_max,
            next_attempt,
            fk_timezone_offset,
            conversation_id,
            from_id,
            to_id,
            from_scheme,
            to_scheme,
            ref_to_message_id,
            failed,
            restored,
            message_subtype,
            action,
            service_type,
            service_value
            FROM
            TB_MESSAGE_UI WHERE
            received BETWEEN systimestamp - INTERVAL '48' HOUR AND systimestamp + INTERVAL '1' HOUR
        </createView>
    </changeSet>
    <changeSet id="EDELIVERY-7677-2" author="Ion Perpegel" dbms="mysql">
        <comment>re-create UI Replication view cause of the added columns: action,service</comment>
        <createView
                replaceIfExists="true"
                viewName="V_MESSAGE_UI_DIFF">
            SELECT
            message_log.MESSAGE_ID,
            message_log.MESSAGE_STATUS,
            message_log.NOTIFICATION_STATUS,
            message_log.MSH_ROLE,
            message_log.MESSAGE_TYPE,
            message_log.DELETED,
            message_log.RECEIVED,
            message_log.SEND_ATTEMPTS,
            message_log.SEND_ATTEMPTS_MAX,
            message_log.NEXT_ATTEMPT,
            message_log.FK_TIMEZONE_OFFSET,
            user_message.COLL_INFO_CONVERS_ID AS CONVERSATION_ID,
            partyid5_.VALUE AS FROM_ID,
            partyid6_.VALUE AS TO_ID,
            property3_.VALUE AS FROM_SCHEME,
            property4_.VALUE AS TO_SCHEME,
            message_info.REF_TO_MESSAGE_ID,
            message_log.FAILED,
            message_log.RESTORED,
            message_log.MESSAGE_SUBTYPE,
            user_message.COLLABORATION_INFO_ACTION AS ACTION,
            user_message.SERVICE_TYPE,
            user_message.SERVICE_VALUE
            FROM
            TB_MESSAGE_LOG message_log
            LEFT OUTER JOIN TB_MESSAGE_INFO message_info ON message_log.MESSAGE_ID = message_info.MESSAGE_ID
            CROSS JOIN TB_USER_MESSAGE user_message
            LEFT OUTER JOIN TB_PROPERTY property3_ ON user_message.ID_PK = property3_.MESSAGEPROPERTIES_ID
            LEFT OUTER JOIN TB_PROPERTY property4_ ON user_message.ID_PK = property4_.MESSAGEPROPERTIES_ID
            LEFT OUTER JOIN TB_PARTY_ID partyid5_ ON user_message.ID_PK = partyid5_.FROM_ID
            LEFT OUTER JOIN TB_PARTY_ID partyid6_ ON user_message.ID_PK = partyid6_.TO_ID

            LEFT JOIN TB_MESSAGE_UI flat_table ON message_log.message_id &lt;=&gt; flat_table.message_id
            AND message_log.message_Status &lt;=&gt; flat_table.message_status
            AND message_log.NOTIFICATION_STATUS &lt;=&gt; flat_table.NOTIFICATION_STATUS
            AND message_log.MSH_ROLE &lt;=&gt; flat_table.MSH_ROLE
            AND message_log.MESSAGE_TYPE &lt;=&gt; flat_table.MESSAGE_TYPE
            AND message_log.DELETED &lt;=&gt; flat_table.DELETED
            AND message_log.RECEIVED &lt;=&gt; flat_table.RECEIVED
            AND message_log.SEND_ATTEMPTS &lt;=&gt; flat_table.SEND_ATTEMPTS
            AND message_log.SEND_ATTEMPTS_MAX &lt;=&gt; flat_table.SEND_ATTEMPTS_MAX
            AND message_log.NEXT_ATTEMPT &lt;=&gt; flat_table.NEXT_ATTEMPT
            AND message_log.FK_TIMEZONE_OFFSET &lt;=&gt; flat_table.FK_TIMEZONE_OFFSET
            AND user_message.COLL_INFO_CONVERS_ID &lt;=&gt; flat_table.CONVERSATION_ID
            AND partyid5_.VALUE &lt;=&gt; flat_table.FROM_ID
            AND partyid6_.VALUE &lt;=&gt; flat_table.TO_ID
            AND property3_.VALUE &lt;=&gt; flat_table.FROM_SCHEME
            AND property4_.VALUE &lt;=&gt; flat_table.TO_SCHEME
            AND message_info.REF_TO_MESSAGE_ID &lt;=&gt; flat_table.REF_TO_MESSAGE_ID
            AND message_log.FAILED &lt;=&gt; flat_table.FAILED
            AND message_log.RESTORED &lt;=&gt; flat_table.RESTORED
            AND message_log.MESSAGE_SUBTYPE &lt;=&gt; flat_table.MESSAGE_SUBTYPE
            AND user_message.COLLABORATION_INFO_ACTION &lt;=&gt; flat_table.ACTION
            AND user_message.SERVICE_TYPE &lt;=&gt; flat_table.SERVICE_TYPE
            AND user_message.SERVICE_VALUE &lt;=&gt; flat_table.SERVICE_VALUE
            WHERE
            user_message.messageInfo_ID_PK = message_info.ID_PK
            AND property3_.NAME = 'originalSender'
            AND property4_.NAME = 'finalRecipient'
            AND message_log.received BETWEEN DATE_SUB(NOW(), INTERVAL 48 HOUR) AND DATE_ADD(NOW(), INTERVAL 1 HOUR)
            AND flat_table.message_id IS NULL

            UNION

            SELECT
            message_log.MESSAGE_ID,
            message_log.MESSAGE_STATUS,
            message_log.NOTIFICATION_STATUS,
            message_log.MSH_ROLE,
            message_log.MESSAGE_TYPE,
            message_log.DELETED,
            message_log.RECEIVED,
            message_log.SEND_ATTEMPTS,
            message_log.SEND_ATTEMPTS_MAX,
            message_log.NEXT_ATTEMPT,
            message_log.FK_TIMEZONE_OFFSET,
            '' AS CONVERSATION_ID,
            partyid7_.VALUE AS FROM_ID,
            partyid8_.VALUE AS TO_ID,
            property5_.VALUE AS FROM_SCHEME,
            property6_.VALUE AS TO_SCHEME,
            messageinf4_.REF_TO_MESSAGE_ID,
            message_log.FAILED,
            message_log.RESTORED,
            message_log.MESSAGE_SUBTYPE,
            NULL AS ACTION,
            NULL AS SERVICE_TYPE,
            NULL AS SERVICE_VALUE
            FROM
            TB_MESSAGE_LOG message_log
            CROSS JOIN TB_MESSAGING messaging
            INNER JOIN TB_SIGNAL_MESSAGE signalmess2_ ON messaging.SIGNAL_MESSAGE_ID = signalmess2_.ID_PK
            LEFT OUTER JOIN TB_MESSAGE_INFO messageinf4_ ON signalmess2_.messageInfo_ID_PK = messageinf4_.ID_PK
            INNER JOIN TB_USER_MESSAGE usermessag3_ ON messaging.USER_MESSAGE_ID = usermessag3_.ID_PK
            LEFT OUTER JOIN TB_PROPERTY property5_ ON usermessag3_.ID_PK = property5_.MESSAGEPROPERTIES_ID
            LEFT OUTER JOIN TB_PROPERTY property6_ ON usermessag3_.ID_PK = property6_.MESSAGEPROPERTIES_ID
            LEFT OUTER JOIN TB_PARTY_ID partyid7_ ON usermessag3_.ID_PK = partyid7_.FROM_ID
            LEFT OUTER JOIN TB_PARTY_ID partyid8_ ON usermessag3_.ID_PK = partyid8_.TO_ID
            CROSS JOIN TB_MESSAGE_INFO messageinf11_

            LEFT JOIN TB_MESSAGE_UI flat_table ON message_log.message_id &lt;=&gt; flat_table.message_id
            AND message_log.message_Status &lt;=&gt; flat_table.message_status
            AND message_log.NOTIFICATION_STATUS &lt;=&gt; flat_table.NOTIFICATION_STATUS
            AND message_log.MSH_ROLE &lt;=&gt; flat_table.MSH_ROLE
            AND message_log.MESSAGE_TYPE &lt;=&gt; flat_table.MESSAGE_TYPE
            AND message_log.DELETED &lt;=&gt; flat_table.DELETED
            AND message_log.RECEIVED &lt;=&gt; flat_table.RECEIVED
            AND message_log.SEND_ATTEMPTS &lt;=&gt; flat_table.SEND_ATTEMPTS
            AND message_log.SEND_ATTEMPTS_MAX &lt;=&gt; flat_table.SEND_ATTEMPTS_MAX
            AND message_log.NEXT_ATTEMPT &lt;=&gt; flat_table.NEXT_ATTEMPT
            AND message_log.FK_TIMEZONE_OFFSET &lt;=&gt; flat_table.FK_TIMEZONE_OFFSET
            AND '' &lt;=&gt; flat_table.CONVERSATION_ID
            AND partyid7_.VALUE &lt;=&gt; flat_table.FROM_ID
            AND partyid8_.VALUE &lt;=&gt; flat_table.TO_ID
            AND property5_.VALUE &lt;=&gt; flat_table.FROM_SCHEME
            AND property6_.VALUE &lt;=&gt; flat_table.TO_SCHEME
            AND messageinf4_.REF_TO_MESSAGE_ID &lt;=&gt; flat_table.REF_TO_MESSAGE_ID
            AND message_log.FAILED &lt;=&gt; flat_table.FAILED
            AND message_log.RESTORED &lt;=&gt; flat_table.RESTORED
            AND message_log.MESSAGE_SUBTYPE &lt;=&gt; flat_table.MESSAGE_SUBTYPE
            WHERE
            usermessag3_.messageInfo_ID_PK = messageinf11_.ID_PK
            AND messageinf4_.MESSAGE_ID = message_log.MESSAGE_ID
            AND messageinf4_.REF_TO_MESSAGE_ID = messageinf11_.MESSAGE_ID
            AND property5_.NAME = 'originalSender'
            AND property6_.NAME = 'finalRecipient'
            AND message_log.received BETWEEN DATE_SUB(NOW(), INTERVAL 48 HOUR) AND DATE_ADD(NOW(), INTERVAL 1 HOUR)
            AND flat_table.message_id IS NULL;
        </createView>
    </changeSet>-->
    <!-- End UI Replication Tables -->

    <include file="migration/changelog-5.0-alter-delta.xml" relativeToChangelogFile="true"/>

    <changeSet id="EDELIVERY-7668"  author="Catalin Enache">
        <createTable tableName="TB_VERSION" remarks="Stores Domibus version and build time">
            <column name="VERSION" type="VARCHAR(30)"/>
            <column name="BUILD_TIME" type="VARCHAR(30)"/>
            <column name="CREATION_TIME" type="TIMESTAMP" defaultValueComputed="${now}">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addUniqueConstraint columnNames="VERSION" tableName="TB_VERSION" constraintName="UK_VERSION" />
    </changeSet>

    <changeSet author="dussath" id="EDELIVERY-4669">
        <comment>Create pull request table</comment>
        <createTable tableName="TB_PULL_REQUEST">
            <column name="PULL_REQUEST_UUID" type="VARCHAR(255)" >
                <constraints primaryKey="true" primaryKeyName="PK_PULL_REQUEST"/>
            </column>
            <column name="MPC" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

    <changeSet author="Sebastian-Ion TINCU" id="EDELIVERY-8384-longblob-data-type" dbms="mysql">
        <modifyDataType tableName="TB_ENCRYPTION_KEY" columnName="SECRET_KEY" newDataType="LONGBLOB" />
        <addNotNullConstraint tableName="TB_ENCRYPTION_KEY" columnName="SECRET_KEY" columnDataType="LONGBLOB" />

        <modifyDataType tableName="TB_ENCRYPTION_KEY" columnName="INIT_VECTOR" newDataType="LONGBLOB" />
        <addNotNullConstraint tableName="TB_ENCRYPTION_KEY" columnName="INIT_VECTOR" columnDataType="LONGBLOB" />

        <modifyDataType tableName="TB_PM_CONFIGURATION_RAW" columnName="XML" newDataType="LONGBLOB" />

        <modifyDataType tableName="TB_PM_CONFIGURATION_RAW_AUD" columnName="XML" newDataType="LONGBLOB" />
    </changeSet>

    <changeSet author="Sebastian-Ion TINCU" id="EDELIVERY-8384-drop-delete-expired-messages-procedures" dbms="oracle">
        <!-- drop existing delete procedures for oracle since they are no longer needed in 5.0 -->
        <sql dbms="oracle">
            DROP PROCEDURE del_expired_downloaded_msgs;
            DROP PROCEDURE del_expired_sent_msgs;
        </sql>
    </changeSet>

    <changeSet author="Sebastian-Ion TINCU" id="EDELIVERY-8384-indices" dbms="oracle">
        <!-- add missing index -->
        <createIndex indexName="IDX_COMMAND_PROP_COMMAND_ID" tableName="TB_COMMAND_PROPERTY">
            <column name="FK_COMMAND"/>
        </createIndex>
    </changeSet>

    <changeSet author="ion perpegel" id="EDELIVERY-8503_1">
        <createTable tableName="TB_LOCK" remarks="Stores keys used for locking/synchronizing in cluster">
            <column name="ID_PK" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="PK_LOCK"/>
            </column>
            <column name="LOCK_KEY" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${now}" name="CREATION_TIME" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${current_db_user}" name="CREATED_BY" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="MODIFICATION_TIME" type="TIMESTAMP"/>
            <column name="MODIFIED_BY" type="VARCHAR(255)"/>
        </createTable>
        <addUniqueConstraint columnNames="LOCK_KEY" constraintName="UK_LOCK_KEY" tableName="TB_LOCK"/>
    </changeSet>

    <changeSet author="ion perpegel" id="EDELIVERY-8503_2">
        <insert tableName="TB_LOCK">
            <column name="ID_PK" value="1" type="BIGINT"/>
            <column name="LOCK_KEY" value="bootstrap-synchronization.lock"/>
        </insert>
    </changeSet>

    <changeSet author="ion perpegel" id="EDELIVERY-8532">
        <createTable tableName="TB_TRUSTSTORE">
            <column name="ID_PK" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="PK_TRUSTSTORE"/>
            </column>
            <column name="NAME" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="TYPE" type="VARCHAR(50)">
                <constraints nullable="false"/>
            </column>
            <column name="PASSWORD" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="CONTENT" type="LONGBLOB">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${now}" name="CREATION_TIME" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${current_db_user}" name="CREATED_BY" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="MODIFICATION_TIME" type="TIMESTAMP"/>
            <column name="MODIFIED_BY" type="VARCHAR(255)"/>
        </createTable>
        <addUniqueConstraint columnNames="NAME" constraintName="UK_NAME" tableName="TB_TRUSTSTORE"/>
    </changeSet>

    <!-- Start EArchive Tables -->
    <changeSet author="Francois Gautier" id="EDELIVERY-8450">
        <createTable tableName="TB_EARCHIVE_BATCH">
            <column name="ID_PK" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="PK_EARCHIVE_BATCH"/>
            </column>
            <column name="BATCH_ID" type="VARCHAR(255)"/>
            <column name="REQUEST_TYPE" type="VARCHAR(255)"/>
            <column name="BATCH_STATUS" type="VARCHAR(255)"/>
            <column name="DATE_REQUESTED" type="TIMESTAMP"/>
            <column name="LAST_PK_USER_MESSAGE" type="BIGINT"/>
            <column name="BATCH_SIZE" type="INT"/>
            <column name="STORAGE_LOCATION" type="VARCHAR(255)"/>
            <column name="ERROR" type="VARCHAR(255)"/>
            <column name="MESSAGEIDS_JSON" type="LONGBLOB"/>
            <column defaultValueComputed="${now}" name="CREATION_TIME" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${current_db_user}" name="CREATED_BY" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="MODIFICATION_TIME" type="TIMESTAMP"/>
            <column name="MODIFIED_BY" type="VARCHAR(255)"/>
        </createTable>

        <createTable tableName="TB_EARCHIVEBATCH_UM">
            <column name="ID_PK" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="PK_EARCHIVEBATCH_UML"/>
            </column>
            <column name="FK_EARCHIVE_BATCH_ID" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="FK_USER_MESSAGE_ID" type="BIGINT">
                <constraints nullable="false"/>
            </column>
        </createTable>
        <addForeignKeyConstraint baseColumnNames="FK_EARCHIVE_BATCH_ID" baseTableName="TB_EARCHIVEBATCH_UM"
                                 constraintName="FK_EARCHIVE_BATCH_ID_FTR" deferrable="false"
                                 initiallyDeferred="false" onDelete="RESTRICT" onUpdate="RESTRICT"
                                 referencedColumnNames="ID_PK" referencedTableName="TB_EARCHIVE_BATCH"/>
        <createTable tableName="TB_EARCHIVE_START">
            <column name="ID_PK" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="PK_EARCHIVE_START"/>
            </column>
            <column name="LAST_PK_USER_MESSAGE" type="BIGINT"/>
            <column name="DESCRIPTION" type="VARCHAR(255)"/>
            <column defaultValueComputed="${now}" name="CREATION_TIME" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column defaultValueComputed="${current_db_user}" name="CREATED_BY" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="MODIFICATION_TIME" type="TIMESTAMP"/>
            <column name="MODIFIED_BY" type="VARCHAR(255)"/>
        </createTable>
    </changeSet>
    <!-- End EArchive Tables -->


    <changeSet author="Cosmin Baciu" id="EDELIVERY-8654">
        <addColumn tableName="TB_PART_INFO">
            <column name="COMPRESSED" type="BOOLEAN" defaultValueBoolean="false"/>
        </addColumn>
    </changeSet>


    <!-- this file must be included in every future changelog-xx-delta.xml -->
    <include file="common/changelog-version-inserts.xml" relativeToChangelogFile="true"/>

</databaseChangeLog>
